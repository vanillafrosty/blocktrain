{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/lru/linkedList.js","webpack:///./src/lru/cache.js","webpack:///./src/pieces.js","webpack:///./src/game.js","webpack:///./src/util.js","webpack:///./src/board.js","webpack:///./src/shadowBoard.js","webpack:///./src/ai.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Node","val","this","next","last","LinkedList","head","tail","node","LRUCache","maxCount","pieceValues","count","max","map","list","undefined","remove","newNode","add","oldestNode","oldest","Pieces","pieces","bag","lru","randomIndex","current","length","Math","floor","random","piece","shuffle","type","matrix","Game","board","AI","gameOverOnce","animationFrame","offset","x","y","totalRotations","currentPiece","newPiece","nextPiece","startTime","resetTime","foreverTime","timeStep","megamanPlaying","playingGame","gameOver","megamanAudio","document","getElementById","pause","play","temp","j","transpose","rotate","rotateCounter","render","drawPiece","drawNext","addEventListener","e","validPos","boardStep","preventDefault","update","checkGameOver","setAttribute","cancelAnimationFrame","handleRotate","response","validateRotate","reRotate","handleUnrotate","handleDrop","ctx","clearRect","width","height","emptyBoard","addKeyListeners","requestAnimationFrame","timestamp","rightOrLeft","between","num","low","high","deltaY","rows","grid","minDelta","dy","deepDup","arr","duped","Array","row","col","randNumRange","min","pow","randSelect","a","b","round","Board","nextPieceCtx","cols","strokeStyle","outlineStrokeStyle","square_width","colors","1","2","3","4","5","6","7","color","drawSquare","maxY","dupOffset","boardUtil","drawSquareOutline","drawNextSquare","s_w","fillStyle","lineWidth","fillRect","strokeRect","beginPath","moveTo","lineTo","stroke","setPiece","clearRows","numRows","startY","fullRow","removeRow","row_idx","newOffset","handleResponse","handledX","handledY","handleX","handleY","handleP","total","peaksRemaining","maxPeak","fullRows","peaks","cumulativeHeight","minPeak","holes","roughness","currPeak","abs","ShadowBoard","setY","AIGame","populationSize","genomes","genomeIndex","movesTaken","movesLimit","genZero","createInitialPopulation","score","generation","mutationRate","mutationStep","speedArr","speedIndex","powerSteps","genome","id","rowsCleared","weightedHeight","relativeHeight","push","evaluateNextGenome","aiDisplay","children","innerHTML","evolve","makeNextMove","fitness","bestFutureMove","bestCurrentMove","possibleMoves","getPossibleMoves","shadowBoard","shadowMove","getHighestRatedMove","rating","updateScore","realMove","move","drop","algorithm","origOffset","rotations","trans","getMaxHeight","getCumulativeHeight","getRelativeHeight","getHoles","getRoughness","updateRating","removePiece","translation","origPiece","multiRotate","shadowOffset","moves","highestMove","controls","removeChild","append","powerWalk","moveIteration","boardIteration","scrubBoard","sort","fittest","slice","makeChild","mom","dad","child","mutate","keys","powerStep","canvas","nextPieceCanvas","game","getContext","tracks","tracksIndex","src","event","toggleAudio","restart"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","class Node {\n\n  constructor(key, val) {\n    this.key = key;\n    this.val = val;\n    this.next = null;\n    this.last = null;\n  }\n\n  remove() {\n    if (this.next) {\n      this.next.last = this.last;\n    }\n    if (this.last) {\n      this.last.next = this.next;\n    }\n    this.next = null;\n    this.last = null;\n  }\n\n\n}\n\nexport default class LinkedList {\n\n  constructor() {\n    //head node is the MRU, tail is the LRU to be ejected\n    this.head = new Node();\n    this.tail = new Node();\n    this.head.last = this.tail;\n    this.tail.next = this.head;\n  }\n\n  add(key, val) {\n    let node = new Node(key,val);\n    node.next = this.head;\n    node.last = this.head.last;\n    this.head.last.next = node;\n    this.head.last = node;\n    return node;\n  }\n\n\n  oldest() {\n    if (this.head.last === this.tail) {\n      return null;\n    } else {\n      return this.tail.next;\n    }\n  }\n\n  // newest() {\n  //   if (this.head.last === this.tail) {\n  //     return null;\n  //   } else {\n  //     return this.head.last;\n  //   }\n  // }\n\n}\n","import LinkedList from './linkedList';\n\nexport default class LRUCache {\n\n  constructor(maxCount, pieceValues) {\n    this.count = 0;\n    this.max = maxCount;\n    this.map = {};\n    this.list = new LinkedList();\n    this.pieceValues = pieceValues;\n  }\n\n  get(key) {\n    if (this.map[key] !== undefined) {\n      let node = this.map[key];\n      node.remove();\n      let newNode = this.list.add(node.key, node.val);\n      this.map[key] = newNode;\n    } else if (this.count < this.max) {\n      let newNode = this.list.add(key, this.pieceValues[key]);\n      this.count += 1;\n      this.map[key] = newNode;\n    } else {\n      let oldestNode = this.list.oldest();\n      oldestNode.remove();\n      delete this.map[oldestNode.key];\n      let newNode = this.list.add(key, this.pieceValues[key]);\n      this.map[key] = newNode;\n    }\n  }\n\n\n}\n","import LRUCache from './lru/cache';\n\nexport default class Pieces {\n\n  constructor() {\n    this.pieces = {\n      'I': [[0,1,0,0],\n            [0,1,0,0],\n            [0,1,0,0],\n            [0,1,0,0]],\n      'O': [[0,0,0,0],\n            [0,2,2,0],\n            [0,2,2,0],\n            [0,0,0,0]],\n      'T': [[0,0,0],\n            [3,3,3],\n            [0,3,0]],\n      'L': [[0,4,0],\n            [0,4,0],\n            [0,4,4]],\n      'J': [[0,5,0],\n            [0,5,0],\n            [5,5,0]],\n      'Z': [[0,0,0],\n            [6,6,0],\n            [0,6,6]],\n      'S': [[0,0,0],\n            [0,7,7],\n            [7,7,0]]\n    };\n    this.bag = ['I','O','T','L','J','Z','S'];\n    this.lru = new LRUCache(3, this.pieces);\n  }\n\n  //the fisher-yates shuffle\n  shuffle() {\n    let randomIndex, current;\n    for (let i=this.bag.length-1; i>=0; i--) {\n      randomIndex = Math.floor(Math.random()*(i+1));\n      current = this.bag[i];\n      this.bag[i] = this.bag[randomIndex];\n      this.bag[randomIndex] = current;\n    }\n    return this.bag;\n  }\n\n  newPiece() {\n    let piece = this.shuffle()[0];\n    while (this.lru.map[piece] !== undefined) {\n      piece = this.shuffle()[0];\n    }\n    this.lru.get(piece);\n    return {\n      type: piece,\n      matrix: this.lru.map[piece].val\n    };\n  }\n\n}\n","import Pieces from './pieces';\n\nexport default class Game {\n\n  constructor(board) {\n    this.AI = false;\n    this.gameOverOnce = false; //to make sure we don't add multiple event listeners\n    this.animationFrame = null;\n    this.board = board;\n    this.offset = {\n      x: 4,\n      y: 0\n    };\n    this.totalRotations = 0;\n    this.pieces = new Pieces();\n    this.currentPiece = this.pieces.newPiece();\n    this.nextPiece = this.pieces.newPiece();\n    this.startTime;\n    this.resetTime = 0;\n    this.foreverTime = 0;\n    this.timeStep = 1000;\n    this.megamanPlaying = false;\n    this.playingGame = false;\n    this.gameOver = false;\n    this.megamanAudio = document.getElementById(\"megaman-theme\");\n  }\n\n  toggleAudio(){\n    if (this.playingGame || this.gameOver) {\n      if (this.megamanPlaying){\n        this.megamanAudio.pause();\n        this.megamanPlaying = false;\n      } else {\n        this.megamanAudio.play();\n        this.megamanPlaying = true;\n      }\n    }\n  }\n\n  //transpose a square matrix with space considerations\n  transpose(matrix) {\n    let temp;\n    for (let i=0; i<matrix.length; i++){\n      for (let j=i+1; j<matrix.length; j++){\n        temp = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = temp;\n      }\n    }\n    return matrix;\n  }\n\n  //we are prioritizing space over time complexity here. creating a new\n  //matrix should give us faster time complexity, but both ways are still O(n^2)\n  rotate(matrix) {\n    let temp;\n    let transposed = this.transpose(matrix);\n    //reverse the columns\n    for (let i=0; i<matrix.length; i++) {\n      for (let j=0; j<Math.floor(matrix.length/2); j++){\n        temp = matrix[i][j];\n        matrix[i][j] = matrix[i][matrix.length-1-j];\n        matrix[i][matrix.length-1-j] = temp;\n      }\n    }\n    return matrix;\n  }\n\n  rotateCounter(matrix) {\n    let temp;\n    let transposed = this.transpose(matrix);\n    //reverse the rows\n    for (let i=0; i<Math.floor(matrix.length/2); i++) {\n      for (let j=0; j<matrix.length; j++){\n        temp = matrix[i][j];\n        matrix[i][j] = matrix[matrix.length-1-i][j];\n        matrix[matrix.length-1-i][j] = temp;\n      }\n    }\n    return matrix;\n  }\n\n  handleRotate(piece) {\n    switch(piece.type) {\n      case 'T':\n      case 'O':\n      case 'J':\n      case 'L':\n        piece.matrix = this.rotate(piece.matrix);\n        return piece;\n      case 'Z':\n      case 'S':\n      case 'I':\n        this.totalRotations += 1;\n        if (this.totalRotations % 2 !== 0) {\n          piece.matrix = this.rotate(piece.matrix);\n        } else {\n          piece.matrix = this.rotateCounter(piece.matrix);\n        }\n        return piece;\n    }\n  }\n\n  handleUnrotate(piece) {\n    switch(piece.type) {\n      case 'T':\n      case 'O':\n      case 'J':\n      case 'L':\n        piece.matrix = this.rotateCounter(piece.matrix);\n        return piece;\n      case 'Z':\n      case 'S':\n      case 'I':\n        //since we're unrotating, at a high level of thinking we\n        //shouldn't actually count another rotation.\n        // this.totalRotations += 1;\n        if (this.totalRotations % 2 !== 0) {\n          piece.matrix = this.rotateCounter(piece.matrix);\n        } else {\n          piece.matrix = this.rotate(piece.matrix);\n        }\n        return piece;\n    }\n  }\n\n  boardStep() {\n    this.board.render();\n    this.board.drawPiece(this.currentPiece.matrix, this.offset);\n    this.board.drawNext(this.nextPiece.matrix);\n  }\n\n  addKeyListeners() {\n    document.addEventListener('keydown', (e) => {\n      switch(e.key) {\n        case 'd':\n        case 'ArrowRight':\n          if (!this.gameOver) {\n            this.offset.x += 1;\n            if (this.board.validPos(this.currentPiece.matrix, this.offset)) {\n              this.boardStep();\n            } else {\n              this.offset.x -= 1;\n            }\n          }\n          break;\n        case 'a':\n        case 'ArrowLeft':\n          if (!this.gameOver) {\n            this.offset.x -= 1;\n            if (this.board.validPos(this.currentPiece.matrix, this.offset)){\n              this.boardStep();\n            } else {\n              this.offset.x += 1;\n            }\n          }\n          break;\n        case 's':\n        case 'ArrowDown':\n          e.preventDefault();\n          if (!this.gameOver){\n            this.offset.y += 1;\n            if (this.board.update(this.currentPiece.matrix, this.offset)) {\n              this.offset.y = 0;\n              this.offset.x = 4;\n              this.totalRotations = 0;\n              this.currentPiece = this.nextPiece;\n              this.nextPiece = this.pieces.newPiece();\n            }\n            this.resetTime = 0;\n            this.boardStep();\n            this.gameOver = this.board.checkGameOver(this.currentPiece.matrix, this.offset);\n            if (this.gameOver) {\n              this.gameOverOnce = true;\n              this.playingGame = false;\n              let notGameOver = document.getElementById('not-game-over');\n              notGameOver.setAttribute(\"id\", \"game-over\");\n              cancelAnimationFrame(this.animationFrame);\n            }\n          }\n          break;\n        case 'w':\n        case 'ArrowUp':\n          e.preventDefault();\n          this.currentPiece = this.handleRotate(this.currentPiece);\n          let response = this.board.validateRotate(this.currentPiece.matrix, this.offset);\n          if (response.reRotate) {\n            this.currentPiece = this.handleUnrotate(this.currentPiece);\n          } else {\n            this.offset = response.offset;\n          }\n          this.boardStep();\n          break;\n        case ' ':\n          e.preventDefault();\n          if (!this.gameOver && this.board.validPos(this.currentPiece.matrix, this.offset)) {\n            e.preventDefault();\n            this.board.handleDrop(this.currentPiece.matrix, this.offset);\n            this.offset.y = 0;\n            this.offset.x = 4;\n            this.totalRotations = 0;\n            this.currentPiece = this.nextPiece;\n            this.nextPiece = this.pieces.newPiece();\n            this.boardStep();\n          }\n      }\n    });\n  }\n\n  restart() {\n    //clear old board because we are not actually clearing HTML canvas before\n    //new game starts playing\n    this.board.ctx.clearRect(0, 0, this.board.width, this.board.height);\n    this.board.emptyBoard();\n    let gameOver = document.getElementById('game-over');\n    gameOver.setAttribute(\"id\", \"not-game-over\");\n    this.animationFrame = null;\n    this.offset = {\n      x: 4,\n      y: 0\n    };\n    this.totalRotations = 0;\n    this.currentPiece = this.pieces.newPiece();\n    this.nextPiece = this.pieces.newPiece();\n    this.startTime = null;\n    this.resetTime = 0;\n    this.timeStep = 1000;\n    this.foreverTime = 0;\n    this.gameOver = false;\n    this.play();\n  }\n\n  play() {\n    if (this.playingGame || this.gameOver) {\n      return true;\n    } else {\n      this.playingGame = true;\n      this.megamanAudio.play();\n      this.megamanPlaying = true;\n\n\n      if (!this.gameOverOnce) {\n        this.addKeyListeners();\n        let gameStart = document.getElementById('before-game-start');\n        gameStart.setAttribute(\"id\", \"game-start\");\n      }\n\n      const render = (timestamp) => {\n        this.resetTime += timestamp-this.startTime;\n        this.foreverTime += timestamp-this.startTime;\n        if (this.foreverTime > 32000) {\n          this.foreverTime = 0;\n          this.timeStep = this.timeStep * 0.9;\n        }\n        if (this.resetTime > this.timeStep) {\n          this.resetTime = 0;\n          this.offset.y += 1;\n          if (this.board.update(this.currentPiece.matrix, this.offset)){\n            this.offset.y = 0;\n            this.offset.x = 4;\n            this.totalRotations = 0;\n            this.currentPiece = this.nextPiece;\n            this.nextPiece = this.pieces.newPiece();\n          }\n          this.boardStep();\n          this.gameOver = this.board.checkGameOver(this.currentPiece.matrix, this.offset);\n          if (this.gameOver) {\n            this.gameOverOnce = true;\n            this.playingGame = false;\n            let notGameOver = document.getElementById('not-game-over');\n            notGameOver.setAttribute(\"id\", \"game-over\");\n            cancelAnimationFrame(this.animationFrame);\n            return true;\n          }\n        }\n        this.startTime = timestamp;\n        this.animationFrame = requestAnimationFrame(render);\n      }\n\n      this.animationFrame = requestAnimationFrame((timestamp) => {\n        this.startTime = timestamp;\n        this.board.drawPiece(this.currentPiece.matrix, this.offset);\n        this.board.drawNext(this.nextPiece.matrix);\n        render(timestamp);\n      });\n    }\n  }\n\n}\n","export const rightOrLeft = (piece, x) => {\n  let middle = Math.floor(piece.length/2);\n  return (x < middle ? 'left':'right');\n}\n\nexport const between = (num, low, high) => {\n  if (num < low || num > high) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n\nexport const deltaY = (piece, offset, rows, grid) => {\n  let minDelta, dy;\n  for (let i=0; i<piece.length; i++){\n    for (let j=0; j<piece[0].length; j++){\n      if (piece[i][j] !== 0) {\n        dy = 0;\n        while((i+offset.y+dy) < rows && !grid[i+offset.y+dy][j+offset.x]){\n          dy += 1;\n        }\n        if (!minDelta || dy < minDelta) { minDelta = dy; }\n      }\n    }\n  }\n  return minDelta;\n}\n\n\nexport const deepDup = (arr) => {\n  let duped = new Array(arr.length);\n  for (let i=0; i<duped.length; i++) {\n    duped[i] = new Array(arr[0].length);\n  }\n  for (let row=0; row<arr.length; row++) {\n    for (let col=0; col<arr[0].length; col++) {\n      duped[row][col] = arr[row][col];\n    }\n  }\n  return duped;\n}\n\nexport const randNumRange = (min, max) => {\n  return Math.floor(Math.pow(Math.random(), 2) * (max - min + 1) + min);\n}\n\nexport const randSelect = (a, b) => {\n  return Math.round(Math.random()) === 0 ? a : b;\n}\n","import * as boardUtil from './util';\n\nexport default class Board {\n\n  constructor(width, height, ctx, nextPieceCtx) {\n    this.ctx = ctx;\n    this.nextPieceCtx = nextPieceCtx;\n    this.width = width;\n    this.height = height;\n    this.rows = 21;\n    this.cols = 10;\n    this.grid = [];\n    this.strokeStyle = '#000000';\n    this.outlineStrokeStyle = '#F9F9F9';\n    this.square_width = width/this.cols;\n    for (let i=0; i<this.rows; i++) {\n      this.grid[i] = new Array(this.cols);\n    }\n    this.colors = {\n      1: '#E24242',\n      2: '#F5DC41',\n      3: '#CC41F5',\n      4: '#3E4AE8',\n      5: '#3EE0E8',\n      6: '#3EE848',\n      7: '#F14D17'\n    };\n    this.emptyBoard = this.emptyBoard.bind(this);\n  }\n\n  emptyBoard() {\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        this.grid[i][j] = undefined;\n      }\n    }\n  }\n\n  render() {\n    this.ctx.clearRect(0, 0, this.width, this.height);\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (typeof(this.grid[i][j]) !== 'undefined') {\n          let x = j*this.square_width;\n          let y = i*this.square_width;\n          let color = this.colors[this.grid[i][j]];\n          this.drawSquare(x,y, color);\n        }\n      }\n    }\n  }\n\n  drawPiece(piece, offset) {\n    let minDelta;\n    let dupOffset = {\n      x: offset.x,\n      y: offset.y\n    };\n    minDelta = boardUtil.deltaY(piece, offset, this.rows, this.grid);\n    dupOffset.y += minDelta-1;\n    let x, y, maxY, color;\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          x = (offset.x+j)*this.square_width;\n          y = (offset.y+i)*this.square_width;\n          maxY = (dupOffset.y+i)*this.square_width;\n          color = this.colors[piece[i][j]];\n          this.drawSquare(x, y, color);\n          this.drawSquareOutline(x, maxY, color);\n        }\n      }\n    }\n  }\n\n\n  drawNext(piece) {\n    const offset = {\n      x: 0,\n      y: 1\n    };\n    //hard code width and height for now\n    this.nextPieceCtx.clearRect(0, 0, 120, 150);\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          let x = (offset.x+j)*this.square_width;\n          let y = (offset.y+i)*this.square_width;\n          let color = this.colors[piece[i][j]];\n          this.drawNextSquare(x, y, color);\n        }\n      }\n    }\n  }\n\n  drawNextSquare(x, y, color){\n    const s_w = this.square_width;\n    this.nextPieceCtx.fillStyle = color;\n    this.nextPieceCtx.strokeStyle = this.strokeStyle;\n    this.nextPieceCtx.lineWidth = 2;\n    this.nextPieceCtx.fillRect(x, y, s_w, s_w);\n    this.nextPieceCtx.strokeRect(x, y, s_w, s_w);\n    this.nextPieceCtx.beginPath();\n    this.nextPieceCtx.moveTo(x+s_w/4, y+s_w*(3/4));\n    this.nextPieceCtx.lineTo(x+s_w/4, y+s_w/4);\n    this.nextPieceCtx.lineTo(x+s_w*(3/4), y+s_w/4);\n    this.nextPieceCtx.stroke();\n  }\n\n  drawSquare(x, y, color)  {\n    const s_w = this.square_width;\n    this.ctx.fillStyle = color;\n    this.ctx.strokeStyle = this.strokeStyle;\n    this.ctx.lineWidth = 2;\n    this.ctx.fillRect(x, y, s_w, s_w);\n    this.ctx.strokeRect(x, y, s_w, s_w);\n    this.ctx.beginPath();\n    this.ctx.moveTo(x+s_w/4, y+s_w*(3/4));\n    this.ctx.lineTo(x+s_w/4, y+s_w/4);\n    this.ctx.lineTo(x+s_w*(3/4), y+s_w/4);\n    this.ctx.stroke();\n  }\n\n  drawSquareOutline(x, y, color) {\n    const s_w = this.square_width;\n    this.ctx.strokeStyle = this.outlineStrokeStyle;\n    this.ctx.lineWidth = 2;\n    this.ctx.strokeRect(x, y, s_w, s_w);\n  }\n\n  update(piece, offset) {\n    if (offset.y < 0) {\n      return false;\n    }\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          let x = offset.x+j;\n          let y = offset.y+i;\n          //we allow y>=this.rows because update is used to set a piece at\n          //the very bottom of the board (in a fresh game). this.grid[y][x]\n          //fails as a check in this case.\n          if (y >= this.rows || typeof(this.grid[y][x]) !== 'undefined') {\n            this.setPiece(piece, offset.x, offset.y-1);\n            this.clearRows(piece.length, offset.y-1);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  clearRows(numRows, startY){\n    for (let i=0; i<numRows; i++) {\n      if (this.fullRow(startY+i)) {\n        this.removeRow(startY+i);\n      }\n    }\n  }\n\n\n\n  fullRow(row_idx){\n    let row = this.grid[row_idx];\n    if (row === undefined) {\n      return false;\n    }\n    for (let i=0; i<row.length; i++) {\n      if (typeof(row[i]) === 'undefined') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  removeRow(row_idx) {\n    let row = this.grid[row_idx];\n    for (let i=row_idx-1; i>=0; i--) {\n      for (let j=0; j<row.length; j++){\n        this.grid[i+1][j] = this.grid[i][j];\n      }\n    }\n    for (let j=0; j<row.length; j++){\n      this.grid[0][j] = undefined;\n    }\n  }\n\n  //updates the grid with the piece values\n  setPiece(piece, x, y) {\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          this.grid[y+i][x+j] = piece[i][j];\n        }\n      }\n    }\n  }\n\n  validPos(piece, offset) {\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          let x = offset.x+j;\n          let y = offset.y+i;\n          if (!boardUtil.between(x, 0, this.cols-1) || !boardUtil.between(y, 0, this.rows-1)) {\n            return false;\n          }\n          if (typeof(this.grid[y][x]) !== 'undefined') {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  //helper method for validateRotate\n  handleResponse(piece, offset, newOffset) {\n    if (this.validPos(piece, newOffset)) {\n      return {\n        reRotate: false,\n        offset: newOffset\n      };\n    } else {\n      return {\n        reRotate: true,\n        offset: offset\n      };\n    }\n  }\n\n  //helper method for validateRotate\n  handleX(x, piece, offset) {\n    let newOffset = {\n      x: offset.x,\n      y: offset.y\n    };\n    if (boardUtil.between(x, 0, this.cols-1)) {\n      return null;\n    }\n    else if (x < 0) {\n      newOffset.x += 1;\n      return this.handleResponse(piece, offset, newOffset);\n    }\n    else if (x > (this.cols-1)) {\n      //reminder: may want to subtract Math.floor(piece.length/2)\n      //to account for the line pieces hugging the right side of the board\n      newOffset.x -=1;\n      return this.handleResponse(piece, offset, newOffset);\n    }\n  }\n\n  handleY(y, piece, offset) {\n    let newOffset = {\n      x: offset.x,\n      y: offset.y\n    };\n    if (boardUtil.between(y, 0, this.rows-1)) {\n      return null;\n    }\n    else if (y < 0) {\n      newOffset.y += 1;\n      return this.handleResponse(piece, offset, newOffset);\n    }\n    else if (y > (this.rows-1)) {\n      newOffset.y -=1;\n      return this.handleResponse(piece, offset, newOffset);\n    }\n  }\n\n  handleP(x, piece, offset) {\n    let newOffset = {\n      x: offset.x,\n      y: offset.y\n    };\n    if (boardUtil.rightOrLeft(piece, x) === 'left') {\n      newOffset.x += 1;\n      //try moving the piece up one before giving up\n      let response = this.handleResponse(piece, offset, newOffset);\n      if (response.reRotate){\n        newOffset.x -= 1;\n        newOffset.y -= 1;\n        return this.handleResponse(piece, offset, newOffset);\n      }\n      return response;\n    } else if (boardUtil.rightOrLeft(piece, x) === 'right'){\n      newOffset.x -=1;\n      let response = this.handleResponse(piece, offset, newOffset);\n      if (response.reRotate) {\n        newOffset.x += 1;\n        newOffset.y -= 1;\n        return this.handleResponse(piece, offset, newOffset);\n      }\n      return response;\n    }\n\n  }\n\n  validateRotate(piece, offset) {\n    let handledX, handledY;\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          let x = offset.x+j;\n          let y = offset.y+i;\n          handledX = this.handleX(x, piece, offset);\n          if (handledX) {\n            return handledX;\n          }\n          handledY = this.handleY(y, piece, offset);\n          if (handledY) {\n            return handledY;\n          }\n          if (typeof(this.grid[y][x]) !== 'undefined') {\n            return this.handleP(x, piece, offset);\n\n          }\n        }\n      }\n    }\n    return {\n      reRotate: false,\n      offset: offset\n    }\n  }\n\n  handleDrop(piece, offset) {\n    let minDelta;\n    minDelta = boardUtil.deltaY(piece, offset, this.rows, this.grid);\n    offset.y += minDelta;\n    this.setPiece(piece, offset.x, offset.y-1);\n    this.clearRows(piece.length, offset.y-1);\n  }\n\n  checkGameOver(piece, offset) {\n    if (offset.y !== 0) { return false; }\n    if (!this.validPos(piece, offset)) {\n      return true;\n    }\n    return false;\n  }\n\n  /*\n   █████  ██     ███    ███ ███████ ████████ ██   ██  ██████  ██████  ███████\n  ██   ██ ██     ████  ████ ██         ██    ██   ██ ██    ██ ██   ██ ██\n  ███████ ██     ██ ████ ██ █████      ██    ███████ ██    ██ ██   ██ ███████\n  ██   ██ ██     ██  ██  ██ ██         ██    ██   ██ ██    ██ ██   ██      ██\n  ██   ██ ██     ██      ██ ███████    ██    ██   ██  ██████  ██████  ███████\n  */\n\n\n\n  fullRows(numRows, startY){\n    let total = 0;\n    for (let i=0; i<numRows; i++) {\n      if (this.fullRow(startY+i)) {\n        total += 1;\n      }\n    }\n    return total;\n  }\n\n  getMaxHeight() {\n    let peaksRemaining = 10;\n    let maxPeak = 0;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined) {\n          peaksRemaining -= 1;\n          if ((this.rows - i) > maxPeak) {\n            maxPeak = this.rows-i;\n          }\n        }\n      }\n    }\n    return maxPeak;\n  }\n\n  getCumulativeHeight(fullRows) {\n    let peaks = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    let peaksRemaining = 10;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined && peaks[j] < 0) {\n          peaks[j] = this.rows-i;\n          peaksRemaining -= 1;\n        }\n      }\n    }\n    let cumulativeHeight = 0;\n    for (let p=0; p<peaks.length; p++) {\n      if (peaks[p] > 0) {\n        cumulativeHeight += peaks[p];\n      }\n    }\n    //do the below because remember we're not actually clearing rows,\n    //just keeping track of how many rows are filled\n    return cumulativeHeight - (fullRows*10);\n  }\n\n  getRelativeHeight() {\n    let peaks = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    let peaksRemaining = 10;\n    let minPeak = 99;\n    let maxPeak = 0;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined && peaks[j] < 0) {\n          peaks[j] = this.rows-i;\n          peaksRemaining -= 1;\n          if (peaks[j] > maxPeak) {\n            maxPeak = peaks[j];\n          }\n          if (peaks[j] < minPeak) {\n            minPeak = peaks[j];\n          }\n        }\n      }\n    }\n    return maxPeak - minPeak;\n  }\n\n  getHoles() {\n    let peaks = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    let peaksRemaining = 10;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined && peaks[j] < 0) {\n          peaks[j] = this.rows-i;\n          peaksRemaining -= 1;\n        }\n      }\n    }\n    let holes = 0;\n    for (let p=0; p<peaks.length; p++) {\n      for (let row=20; row>(this.rows-peaks[p]); row--) {\n        if (this.grid[row][p] === undefined) {\n          holes += 1;\n        }\n      }\n    }\n    return holes;\n  }\n\n  //roughness is the sum of relative height differences between columns\n  getRoughness() {\n    let roughness = 0;\n    let peaks = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    let peaksRemaining = 10;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined && peaks[j] < 0) {\n          peaks[j] = this.rows-i;\n          peaksRemaining -= 1;\n        }\n      }\n    }\n    for (let p=0; p<peaks.length-1; p++) {\n      let currPeak = peaks[p+1] < 0 ? 0 : peaks[p+1];\n      roughness += Math.abs(peaks[p] - currPeak);\n    }\n    return roughness;\n  }\n\n  removePiece(piece, x, y) {\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          this.grid[y+i][x+j] = undefined;\n        }\n      }\n    }\n  }\n\n\n}\n","import * as boardUtil from './util';\n\nexport default class ShadowBoard {\n\n  constructor(grid) {\n    this.grid = grid;\n    this.rows = grid.length;\n    this.cols = grid[0].length;\n    this.emptyBoard = this.emptyBoard.bind(this);\n  }\n\n  emptyBoard() {\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        this.grid[i][j] = undefined;\n      }\n    }\n  }\n\n  update(piece, offset) {\n    if (offset.y < 0) {\n      return false;\n    }\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          let x = offset.x+j;\n          let y = offset.y+i;\n          if (y >= this.rows || typeof(this.grid[y][x]) !== 'undefined') {\n            this.setPiece(piece, offset.x, offset.y-1);\n            this.clearRows(piece.length, offset.y-1);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  clearRows(numRows, startY){\n    for (let i=0; i<numRows; i++) {\n      if (this.fullRow(startY+i)) {\n        this.removeRow(startY+i);\n      }\n    }\n  }\n\n\n\n  fullRow(row_idx){\n    let row = this.grid[row_idx];\n    if (row === undefined) {\n      return false;\n    }\n    for (let i=0; i<row.length; i++) {\n      if (typeof(row[i]) === 'undefined') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  removeRow(row_idx) {\n    let row = this.grid[row_idx];\n    for (let i=row_idx-1; i>=0; i--) {\n      for (let j=0; j<row.length; j++){\n        this.grid[i+1][j] = this.grid[i][j];\n      }\n    }\n    for (let j=0; j<row.length; j++){\n      this.grid[0][j] = undefined;\n    }\n  }\n\n  //updates the grid with the piece values\n  setPiece(piece, x, y) {\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          this.grid[y+i][x+j] = piece[i][j];\n        }\n      }\n    }\n  }\n\n  validPos(piece, offset) {\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          let x = offset.x+j;\n          let y = offset.y+i;\n          if (!boardUtil.between(x, 0, this.cols-1) || !boardUtil.between(y, 0, this.rows-1)) {\n            return false;\n          }\n          if (typeof(this.grid[y][x]) !== 'undefined') {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  //helper method for validateRotate\n  handleResponse(piece, offset, newOffset) {\n    if (this.validPos(piece, newOffset)) {\n      return {\n        reRotate: false,\n        offset: newOffset\n      };\n    } else {\n      return {\n        reRotate: true,\n        offset: offset\n      };\n    }\n  }\n\n  //helper method for validateRotate\n  handleX(x, piece, offset) {\n    let newOffset = {\n      x: offset.x,\n      y: offset.y\n    };\n    if (boardUtil.between(x, 0, this.cols-1)) {\n      return null;\n    }\n    else if (x < 0) {\n      newOffset.x += 1;\n      return this.handleResponse(piece, offset, newOffset);\n    }\n    else if (x > (this.cols-1)) {\n      //reminder: may want to subtract Math.floor(piece.length/2)\n      //to account for the line pieces hugging the right side of the board\n      newOffset.x -=1;\n      return this.handleResponse(piece, offset, newOffset);\n    }\n  }\n\n  handleY(y, piece, offset) {\n    let newOffset = {\n      x: offset.x,\n      y: offset.y\n    };\n    if (boardUtil.between(y, 0, this.rows-1)) {\n      return null;\n    }\n    else if (y < 0) {\n      newOffset.y += 1;\n      return this.handleResponse(piece, offset, newOffset);\n    }\n    else if (y > (this.rows-1)) {\n      newOffset.y -=1;\n      return this.handleResponse(piece, offset, newOffset);\n    }\n  }\n\n  handleP(x, piece, offset) {\n    let newOffset = {\n      x: offset.x,\n      y: offset.y\n    };\n    if (boardUtil.rightOrLeft(piece, x) === 'left') {\n      newOffset.x += 1;\n      //try moving the piece up one before giving up\n      let response = this.handleResponse(piece, offset, newOffset);\n      if (response.reRotate){\n        newOffset.x -= 1;\n        newOffset.y -= 1;\n        return this.handleResponse(piece, offset, newOffset);\n      }\n      return response;\n    } else if (boardUtil.rightOrLeft(piece, x) === 'right'){\n      newOffset.x -=1;\n      let response = this.handleResponse(piece, offset, newOffset);\n      if (response.reRotate) {\n        newOffset.x += 1;\n        newOffset.y -= 1;\n        return this.handleResponse(piece, offset, newOffset);\n      }\n      return response;\n    }\n\n  }\n\n  validateRotate(piece, offset) {\n    let handledX, handledY;\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          let x = offset.x+j;\n          let y = offset.y+i;\n          handledX = this.handleX(x, piece, offset);\n          if (handledX) {\n            return handledX;\n          }\n          handledY = this.handleY(y, piece, offset);\n          if (handledY) {\n            return handledY;\n          }\n          if (typeof(this.grid[y][x]) !== 'undefined') {\n            return this.handleP(x, piece, offset);\n\n          }\n        }\n      }\n    }\n    return {\n      reRotate: false,\n      offset: offset\n    }\n  }\n\n  handleDrop(piece, offset) {\n    let minDelta;\n    let setY;\n    minDelta = boardUtil.deltaY(piece, offset, this.rows, this.grid);\n    offset.y += minDelta;\n    if (offset.y === 0) {\n      setY = 0;\n    } else {\n      setY = offset.y-1;\n    }\n    this.setPiece(piece, offset.x, setY);\n    this.clearRows(piece.length, setY);\n  }\n\n  checkGameOver(piece, offset) {\n    if (offset.y !== 0) { return false; }\n    if (!this.validPos(piece, offset)) {\n      return true;\n    }\n    return false;\n  }\n\n  /*\n   █████  ██     ███    ███ ███████ ████████ ██   ██  ██████  ██████  ███████\n  ██   ██ ██     ████  ████ ██         ██    ██   ██ ██    ██ ██   ██ ██\n  ███████ ██     ██ ████ ██ █████      ██    ███████ ██    ██ ██   ██ ███████\n  ██   ██ ██     ██  ██  ██ ██         ██    ██   ██ ██    ██ ██   ██      ██\n  ██   ██ ██     ██      ██ ███████    ██    ██   ██  ██████  ██████  ███████\n  */\n\n\n\n  fullRows(numRows, startY){\n    let total = 0;\n    for (let i=0; i<numRows; i++) {\n      if (this.fullRow(startY+i)) {\n        total += 1;\n      }\n    }\n    return total;\n  }\n\n  getMaxHeight() {\n    let peaksRemaining = 10;\n    let maxPeak = 0;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined) {\n          peaksRemaining -= 1;\n          if ((this.rows - i) > maxPeak) {\n            maxPeak = this.rows-i;\n          }\n        }\n      }\n    }\n    return maxPeak;\n  }\n\n  getCumulativeHeight(fullRows) {\n    let peaks = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    let peaksRemaining = 10;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined && peaks[j] < 0) {\n          peaks[j] = this.rows-i;\n          peaksRemaining -= 1;\n        }\n      }\n    }\n    let cumulativeHeight = 0;\n    for (let p=0; p<peaks.length; p++) {\n      if (peaks[p] > 0) {\n        cumulativeHeight += peaks[p];\n      }\n    }\n    //do the below because remember we're not actually clearing rows,\n    //just keeping track of how many rows are filled\n    return cumulativeHeight - (fullRows*10);\n  }\n\n  getRelativeHeight() {\n    let peaks = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    let peaksRemaining = 10;\n    let minPeak = 99;\n    let maxPeak = 0;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined && peaks[j] < 0) {\n          peaks[j] = this.rows-i;\n          peaksRemaining -= 1;\n          if (peaks[j] > maxPeak) {\n            maxPeak = peaks[j];\n          }\n          if (peaks[j] < minPeak) {\n            minPeak = peaks[j];\n          }\n        }\n      }\n    }\n    return maxPeak - minPeak;\n  }\n\n  getHoles() {\n    let peaks = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    let peaksRemaining = 10;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined && peaks[j] < 0) {\n          peaks[j] = this.rows-i;\n          peaksRemaining -= 1;\n        }\n      }\n    }\n    let holes = 0;\n    for (let p=0; p<peaks.length; p++) {\n      for (let row=0; row<peaks[p]; row++) {\n        if (this.grid[row][p] === undefined) {\n          holes += 1;\n        }\n      }\n    }\n    return holes;\n  }\n\n  //roughness is the sum of relative height differences between columns\n  getRoughness() {\n    let roughness = 0;\n    let peaks = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    let peaksRemaining = 10;\n    for (let i=0; i<this.rows; i++) {\n      for (let j=0; j<this.cols; j++) {\n        if (peaksRemaining === 0) {\n          break;\n        }\n        if (this.grid[i][j] !== undefined && peaks[j] < 0) {\n          peaks[j] = this.rows-i;\n          peaksRemaining -= 1;\n        }\n      }\n    }\n    for (let p=0; p<peaks.length-1; p++) {\n      let currPeak = peaks[p+1] < 0 ? 0 : peaks[p+1];\n      roughness += Math.abs(peaks[p] - currPeak);\n    }\n    return roughness;\n  }\n\n  removePiece(piece, x, y) {\n    for (let i=0; i<piece.length; i++) {\n      for (let j=0; j<piece[0].length; j++) {\n        if (piece[i][j] !== 0) {\n          this.grid[y+i][x+j] = undefined;\n        }\n      }\n    }\n  }\n\n\n\n}\n","import Game from './game';\nimport * as boardUtil from './util';\nimport ShadowBoard from './shadowBoard';\n\nexport default class AIGame extends Game {\n\n  constructor(board) {\n    super(board);\n    this.AI = true;\n    this.populationSize = 50;\n    this.genomes = [];\n    this.genomeIndex = -1;\n    this.movesTaken = 0;\n    this.movesLimit = 500;\n    this.genZero = false;\n    this.createInitialPopulation();\n    this.timeStep = 90;\n    this.score = 0;\n    this.generation = 25;\n    this.mutationRate = 0.05;\n    this.mutationStep = 0.2;\n    this.speedArr = [300, 90, 10, 0];\n    this.speedIndex = 1;\n    this.powerSteps = 5;\n  }\n\n\n  createInitialPopulation() {\n    let genome;\n    for (let i=0; i<this.populationSize; i++) {\n      genome = this.genZero ? {\n   \t\t\tid: Math.random(),\n   \t\t\trowsCleared: Math.random() - 0.5,\n   \t\t\tweightedHeight: Math.random() - 0.5,\n   \t\t\tcumulativeHeight: Math.random() - 0.5,\n   \t\t\trelativeHeight: Math.random() - 0.5,\n   \t\t\tholes: Math.random() * 0.5,\n   \t\t\troughness: Math.random() - 0.5,\n      } : {\n        cumulativeHeight: -0.5959229477940513,\n        holes: 0.078680173605579,\n        id: 0.5532957017242564,\n        relativeHeight: 0.0266789627391546,\n        roughness: -0.10651581907940999,\n        rowsCleared: 0.4944378291698683,\n        weightedHeight: 0.003521223515799754\n      };\n\n      this.genomes.push(genome);\n    }\n    this.evaluateNextGenome();\n  }\n\n  evaluateNextGenome() {\n    this.score = 0;\n    this.genomeIndex += 1;\n    if (this.playingGame) {\n      let aiDisplay = document.getElementById('ai-display');\n      aiDisplay.children[2].innerHTML = `current genome: ${this.genomeIndex+1}/${this.populationSize}`;\n      if (this.genomeIndex >= this.genomes.length) {\n        this.evolve();\n        aiDisplay.children[2].innerHTML = `current genome: ${this.genomeIndex+1}/${this.populationSize}`;\n      }\n    }\n    this.movesTaken = 0;\n    this.makeNextMove();\n  }\n\n  makeNextMove() {\n    this.movesTaken += 1;\n    if (this.movesTaken > this.movesLimit) {\n      //evaluate the score for the current genome, and move to the next genome\n      this.genomes[this.genomeIndex].fitness = this.score;\n      this.evaluateNextGenome();\n    } else {\n      let bestFutureMove, bestCurrentMove;\n      //possible moves with this.currentPiece\n      let possibleMoves = this.getPossibleMoves(this.board, this.currentPiece);\n      for (let i=0; i<possibleMoves.length; i++) {\n        this.shadowBoard = new ShadowBoard(boardUtil.deepDup(this.board.grid));\n        this.shadowMove(possibleMoves[i], this.currentPiece);\n        bestFutureMove = this.getHighestRatedMove(this.getPossibleMoves(this.shadowBoard, this.nextPiece));\n        if (bestFutureMove) {\n          possibleMoves[i].rating += bestFutureMove.rating;\n        }\n      }\n      bestCurrentMove = this.getHighestRatedMove(possibleMoves);\n      //based on the bestCurrentMove, move this.currentPiece and set it on this.board\n      this.updateScore(bestCurrentMove);\n      //make sure realMove does not update this.offset.x to be NaN\n      //if bestCurrentMove is not a real move.\n      this.realMove(bestCurrentMove, this.currentPiece);\n      //draw stuff because we just made the best move\n      if (this.timeStep > 0) {\n        this.boardStep();\n      }\n    }\n  }\n\n  updateScore(move) {\n    if (!move) {\n      return true;\n    }\n    this.score += move.drop;\n    switch(move.algorithm.rowsCleared) {\n      case 1:\n        this.score += 400;\n        return true;\n      case 2:\n        this.score += 1000;\n        return true;\n      case 3:\n        this.score += 3000;\n        return true;\n      case 4:\n        this.score += 12000;\n        return true;\n    }\n  }\n\n  getPossibleMoves(board, piece) {\n    let origOffset = {\n      x: this.offset.x,\n      y: this.offset.y\n    };\n    let possibleMoves = [];\n    let rotationsHsh = {\n      'T': 4,\n      'O': 1,\n      'J': 4,\n      'L': 4,\n      'Z': 2,\n      'S': 2,\n      'I': 2\n    }\n    let rotations = rotationsHsh[piece.type];\n    for (let i=1; i<=rotations; i++) {\n      //since handleRotate is destructive, just keep rotating once.\n      //call multiRotate some other time.\n      piece = this.handleRotate(piece);\n      for (let trans=-5; trans<=5; trans++) {\n        let gameOver = false;\n        this.offset.x = origOffset.x;\n        this.offset.y = origOffset.y;\n        this.offset.x += trans;\n        if (board.validPos(piece.matrix, this.offset)) {\n          let minDelta = boardUtil.deltaY(piece.matrix, this.offset, board.rows, board.grid);\n          this.offset.y += minDelta;\n          board.setPiece(piece.matrix, this.offset.x, this.offset.y-1);\n          let rowsCleared = board.fullRows(piece.length, this.offset.y-1);\n          if (rowsCleared === 0) {\n            gameOver = board.checkGameOver(this.nextPiece.matrix, origOffset);\n          }\n          let algorithm = {\n  \t\t\t\t\trowsCleared: rowsCleared,\n  \t\t\t\t\tweightedHeight: Math.pow(board.getMaxHeight(), 1.5),\n  \t\t\t\t\tcumulativeHeight: board.getCumulativeHeight(rowsCleared),\n  \t\t\t\t\trelativeHeight: board.getRelativeHeight(),\n  \t\t\t\t\tholes: board.getHoles(),\n  \t\t\t\t\troughness: board.getRoughness()\n          };\n   \t\t\t\tlet rating = this.updateRating(algorithm);\n   \t\t\t\t//if the move loses the game, slam its rating\n   \t\t\t\tif (gameOver) {\n   \t\t\t\t\trating -= 500;\n   \t\t\t\t}\n          board.removePiece(piece.matrix, this.offset.x, this.offset.y-1);\n   \t\t\t\t//push all possible moves, with their associated ratings and parameter values to an array\n   \t\t\t\tpossibleMoves.push({rotations: i, translation: trans, rating: rating, algorithm: algorithm, drop: minDelta-1});\n        }\n      }\n    }\n    this.offset = origOffset;\n    this.totalRotations = 0;\n    return possibleMoves;\n  }\n\n  updateRating(algorithm) {\n    let rating = 0;\n    rating += algorithm.rowsCleared * this.genomes[this.genomeIndex].rowsCleared;\n    rating += algorithm.weightedHeight * this.genomes[this.genomeIndex].weightedHeight;\n    rating += algorithm.cumulativeHeight * this.genomes[this.genomeIndex].cumulativeHeight;\n    rating += algorithm.relativeHeight * this.genomes[this.genomeIndex].relativeHeight;\n    rating += algorithm.holes * this.genomes[this.genomeIndex].holes;\n    rating += algorithm.roughness * this.genomes[this.genomeIndex].roughness;\n    return rating;\n  }\n\n  multiRotate(piece, rotations) {\n    for (let r=0; r<rotations; r++) {\n      piece = this.handleRotate(piece);\n    }\n    return piece;\n  }\n\n  shadowMove(move, piece) {\n    let origPiece = boardUtil.deepDup(piece.matrix);\n    piece = this.multiRotate(piece, move.rotations);\n    let shadowOffset = {\n      x: this.offset.x,\n      y: this.offset.y\n    }\n    shadowOffset.x += move.translation;\n    this.shadowBoard.handleDrop(piece.matrix, shadowOffset);\n    piece.matrix = origPiece;\n  }\n\n  realMove(move, piece) {\n    if (!move) {\n      return true;\n    }\n    piece = this.multiRotate(piece, move.rotations);\n    this.offset.x += move.translation;\n    this.totalRotations = 0;\n  }\n\n  getHighestRatedMove(moves) {\n    let highestMove = moves[0];\n    if (moves.length === 0) {\n      return null;\n    }\n    for (let i=1; i<moves.length; i++) {\n      if (moves[i].rating > highestMove.rating) {\n        highestMove = moves[i];\n      }\n    }\n    return highestMove;\n  }\n\n  play() {\n    if (this.playingGame || this.gameOver) {\n      return true;\n    } else {\n      this.playingGame = true;\n      this.megamanAudio.play();\n      this.megamanPlaying = true;\n\n\n      if (!this.gameOverOnce) {\n        this.addKeyListeners();\n        let gameStart = document.getElementById('before-game-start');\n        gameStart.setAttribute(\"id\", \"game-start\");\n        let controls = document.getElementById('controls-container');\n        while (controls.children.length > 1) {\n          controls.removeChild(controls.children[1]);\n        }\n        let aiDisplay = document.getElementById('ai-display-none');\n        aiDisplay.setAttribute(\"id\", \"ai-display\");\n        aiDisplay.children[1].append(` ${this.generation}`);\n        aiDisplay.children[2].append(` ${this.genomeIndex+1}/${this.populationSize}`)\n      }\n\n      const render = (timestamp) => {\n        this.resetTime += timestamp-this.startTime;\n\n        if (this.timeStep === 0) {\n          this.powerWalk();\n        } else if (this.resetTime > this.timeStep) {\n          this.resetTime = 0;\n          this.offset.y += 1;\n          if (this.board.update(this.currentPiece.matrix, this.offset)){\n            this.moveIteration();\n          }\n          this.boardStep();\n          this.gameOver = this.board.checkGameOver(this.currentPiece.matrix, this.offset);\n          if (this.gameOver) {\n            this.boardIteration();\n          }\n        }\n        this.startTime = timestamp;\n        this.animationFrame = requestAnimationFrame(render);\n      }\n\n      this.animationFrame = requestAnimationFrame((timestamp) => {\n        this.startTime = timestamp;\n        this.board.drawPiece(this.currentPiece.matrix, this.offset);\n        this.board.drawNext(this.nextPiece.matrix);\n        render(timestamp);\n      });\n    }\n  }\n\n  evolve() {\n    this.generation += 1;\n    let node = document.getElementById('ai-display');\n    node.children[1].innerHTML = (`current generation: ${this.generation}`);\n    this.genomeIndex = 0;\n    this.movesTaken = 0;\n    this.scrubBoard();\n    this.genomes.sort( (a,b) => {\n      return b.fitness - a.fitness;\n    });\n    let fittest = this.genomes.slice(0,Math.floor(this.populationSize/2));\n    let children = [this.genomes[0]];\n    while (children.length < this.populationSize) {\n      children.push(this.makeChild(fittest));\n    }\n    this.genomes = children;\n\n  }\n\n  makeChild(genomes) {\n    let mom = genomes[boardUtil.randNumRange(0, genomes.length-1)];\n    let dad = genomes[boardUtil.randNumRange(0, genomes.length-1)];\n    while (dad === mom) {\n      dad = genomes[boardUtil.randNumRange(0, genomes.length-1)];\n    }\n    let child = {\n      id : Math.random(),\n      rowsCleared: boardUtil.randSelect(mom.rowsCleared, dad.rowsCleared),\n      weightedHeight: boardUtil.randSelect(mom.weightedHeight, dad.weightedHeight),\n      cumulativeHeight: boardUtil.randSelect(mom.cumulativeHeight, dad.cumulativeHeight),\n      relativeHeight: boardUtil.randSelect(mom.relativeHeight, dad.relativeHeight),\n      holes: boardUtil.randSelect(mom.holes, dad.holes),\n      roughness: boardUtil.randSelect(mom.roughness, dad.roughness),\n      fitness: -1\n    };\n    this.mutate(child);\n    return child;\n\n  }\n\n  mutate(child) {\n    let keys = Object.keys(child);\n    for (let i=0; i<keys.length; i++) {\n      if (keys[i] === \"fitness\") {\n        continue;\n      }\n      if (Math.random() < this.mutationRate) {\n        child[keys[i]] = child[keys[i]] + Math.random() * this.mutationStep * 2 - this.mutationStep;\n      }\n    }\n  }\n\n\n  addKeyListeners() {\n    document.addEventListener('keydown', (e) => {\n      if (e.key === 's') {\n        this.speedIndex = (this.speedIndex + 1) % this.speedArr.length;\n        this.timeStep = this.speedArr[this.speedIndex];\n      }\n      else if (e.key === 'z') {\n        this.genZero = true;\n        this.genomes = [];\n        this.genomeIndex = -1;\n        this.movesTaken = 0;\n        this.movesLimit = 500;\n        this.timeStep = 90;\n        this.speedIndex = 1;\n        this.generation = 0;\n        this.scrubBoard();\n        let node = document.getElementById('ai-display');\n        node.children[1].innerHTML = (`current generation: ${this.generation}`);\n        this.createInitialPopulation();\n      }\n    });\n  }\n\n  moveIteration() {\n    this.offset.y = 0;\n    this.offset.x = 4;\n    this.totalRotations = 0;\n    this.currentPiece = this.nextPiece;\n    this.nextPiece = this.pieces.newPiece();\n    this.makeNextMove();\n  }\n\n  boardIteration() {\n    this.genomes[this.genomeIndex].fitness = this.score;\n    this.scrubBoard();\n    this.evaluateNextGenome();\n  }\n\n  scrubBoard() {\n    this.score = 0;\n    this.totalRotations = 0;\n    this.currentPiece = this.nextPiece;\n    this.nextPiece = this.pieces.newPiece();\n    this.board.emptyBoard();\n  }\n\n  powerStep() {\n    this.board.handleDrop(this.currentPiece.matrix, this.offset);\n    this.moveIteration();\n    this.gameOver = this.board.checkGameOver(this.currentPiece.matrix, this.offset);\n    if (this.gameOver) {\n      this.boardIteration();\n    }\n  }\n\n  powerWalk() {\n    for (let i=0; i<this.powerSteps; i++) {\n      this.powerStep();\n    }\n  }\n\n}\n","import Game from './game';\nimport Board from './board';\nimport AIGame from './ai';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const canvas = document.getElementById(\"canvas\");\n  canvas.width = 300;\n  canvas.height = 630;\n  const nextPieceCanvas = document.getElementById(\"next-piece-canvas\");\n  nextPieceCanvas.width = 120;\n  nextPieceCanvas.height = 150;\n\n  let ctx = canvas.getContext('2d');\n  let nextPieceCtx = nextPieceCanvas.getContext('2d');\n\n  let board = new Board(canvas.width, canvas.height, ctx, nextPieceCtx);\n  // let game = new AIGame(board);\n  let game;\n\n\n\n  const tracks = [\n    \"./music/metal-man.mp3\",\n    \"./music/crash-man.mp3\",\n    \"./music/dr-wily.mp3\"\n  ];\n  let tracksIndex = 0;\n  const megamanAudio = document.getElementById(\"megaman-theme\");\n  megamanAudio.addEventListener(\"ended\", () => {\n    tracksIndex = (tracksIndex+1) % tracks.length;\n    megamanAudio.src = tracks[tracksIndex];\n    megamanAudio.play();\n  });\n\n  document.addEventListener(\"keypress\", (event) => {\n    if (event.key === 'p'){\n      if (!game) {\n        game = new Game(board);\n      }\n      game.play();\n    } else if (event.key === 'a') {\n      if (!game) {\n        game = new AIGame(board);\n      }\n      game.play();\n    }\n  });\n\n  document.addEventListener(\"keypress\", (event) => {\n    if (event.key === 'm'){\n      game.toggleAudio();\n    } else if (event.key === 'r') {\n      if (!game.AI && game.gameOver) {\n        game.restart();\n      }\n    }\n  });\n\n\n});\n"],"sourceRoot":""}